import{_ as xe,r as _,y as T,w as Ce,o as Me,a as Q,c as V,b as u,i as ee,n as U,x as ke,F as te,d as Pe,t as H,h as G,e as B,f as F,z as He,p as Ae,g as Qe}from"./index-5eeae3de.js";var se={},q={},N={},I={};/**
 * @license MIT
 * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>
 *
 * @class
 */let Ve=class z{constructor(e,t,s){if(typeof e!="function")throw new Error("Heap constructor expects a compare function");this._compare=e,this._nodes=Array.isArray(t)?t:[],this._leaf=s||null,this._nodes.length>0&&this.fix()}toArray(){return Array.from(this._nodes)}_hasLeftChild(e){return e*2+1<this.size()}_hasRightChild(e){return e*2+2<this.size()}_compareAt(e,t){return this._compare(this._nodes[e],this._nodes[t])}_swap(e,t){const s=this._nodes[e];this._nodes[e]=this._nodes[t],this._nodes[t]=s}_shouldSwap(e,t){return e<0||e>=this.size()||t<0||t>=this.size()?!1:this._compareAt(e,t)>0}_compareChildrenOf(e){if(!this._hasLeftChild(e)&&!this._hasRightChild(e))return-1;const t=e*2+1,s=e*2+2;return this._hasLeftChild(e)?this._hasRightChild(e)&&this._compareAt(t,s)>0?s:t:s}_compareChildrenBefore(e,t,s){return this._compareAt(s,t)<=0&&s<e?s:t}_heapifyUp(e){let t=e,s=Math.floor((t-1)/2);for(;this._shouldSwap(s,t);)this._swap(s,t),t=s,s=Math.floor((t-1)/2)}_heapifyDown(e){let t=e,s=this._compareChildrenOf(t);for(;this._shouldSwap(t,s);)this._swap(t,s),t=s,s=this._compareChildrenOf(t)}_heapifyDownUntil(e){let t=0,s=1,n=2,l;for(;s<e;)l=this._compareChildrenBefore(e,s,n),this._shouldSwap(t,l)&&this._swap(t,l),t=l,s=t*2+1,n=t*2+2}insert(e){return this._nodes.push(e),this._heapifyUp(this.size()-1),(this._leaf===null||this._compare(e,this._leaf)>0)&&(this._leaf=e),this}push(e){return this.insert(e)}extractRoot(){if(this.isEmpty())return null;const e=this.root();return this._nodes[0]=this._nodes[this.size()-1],this._nodes.pop(),this._heapifyDown(0),e===this._leaf&&(this._leaf=null),e}pop(){return this.extractRoot()}sort(){for(let e=this.size()-1;e>0;e-=1)this._swap(0,e),this._heapifyDownUntil(e);return this._nodes}fix(){for(let e=Math.floor(this.size()/2)-1;e>=0;e-=1)this._heapifyDown(e);for(let e=Math.floor(this.size()/2);e<this.size();e+=1){const t=this._nodes[e];(this._leaf===null||this._compare(t,this._leaf)>0)&&(this._leaf=t)}return this}isValid(){const e=t=>{let s=!0,n=!0;if(this._hasLeftChild(t)){const l=t*2+1;if(this._compareAt(t,l)>0)return!1;s=e(l)}if(this._hasRightChild(t)){const l=t*2+2;if(this._compareAt(t,l)>0)return!1;n=e(l)}return s&&n};return e(0)}clone(){return new z(this._compare,this._nodes.slice(),this._leaf)}root(){return this.isEmpty()?null:this._nodes[0]}top(){return this.root()}leaf(){return this._leaf}size(){return this._nodes.length}isEmpty(){return this.size()===0}clear(){this._nodes=[],this._leaf=null}[Symbol.iterator](){let e=this.size();return{next:()=>(e-=1,{value:this.pop(),done:e===-1})}}static heapify(e,t){if(!Array.isArray(e))throw new Error("Heap.heapify expects an array of values");if(typeof t!="function")throw new Error("Heap.heapify expects a compare function");return new z(t,e).fix()}static isHeapified(e,t){return new z(t,e).isValid()}};I.Heap=Ve;var re={};/**
 * @license MIT
 * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>
 */const{Heap:Ee}=I,Oe=p=>(e,t)=>{const s=typeof p=="function"?p(e):e,n=typeof p=="function"?p(t):t;return s<=n?-1:1};let ze=class S extends Ee{constructor(e,t){super(Oe(e),t),this._getCompareValue=e}insert(e){return super.insert(e),this}push(e){return this.insert(e)}fix(){return super.fix(),this}clone(){return new S(this._getCompareValue,this._nodes.slice())}static heapify(e,t){if(!Array.isArray(e))throw new Error("MinHeap.heapify expects an array");return new S(t,e)}static isHeapified(e,t){return new S(t,e).isValid()}};re.MinHeap=ze;var ae={};/**
 * @license MIT
 * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>
 */const{Heap:Se}=I,$e=p=>(e,t)=>{const s=typeof p=="function"?p(e):e,n=typeof p=="function"?p(t):t;return s<n?1:-1};let qe=class $ extends Se{constructor(e,t){super($e(e),t),this._getCompareValue=e}insert(e){return super.insert(e),this}push(e){return this.insert(e)}fix(){return super.fix(),this}clone(){return new $(this._getCompareValue,this._nodes.slice())}static heapify(e,t){if(!Array.isArray(e))throw new Error("MaxHeap.heapify expects an array");return new $(t,e)}static isHeapified(e,t){return new $(t,e).isValid()}};ae.MaxHeap=qe;const{Heap:Ne}=I,{MinHeap:Ie}=re,{MaxHeap:Re}=ae;N.Heap=Ne;N.MinHeap=Ie;N.MaxHeap=Re;/**
 * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>
 * @license MIT
 */const{Heap:De}=N;let j=class{constructor(e,t){if(typeof e!="function")throw new Error("PriorityQueue constructor expects a compare function");this._heap=new De(e,t)}front(){return this._heap.root()}back(){return this._heap.leaf()}enqueue(e){return this._heap.insert(e),this}push(e){return this.enqueue(e)}dequeue(){return this._heap.extractRoot()}pop(){return this.dequeue()}remove(e){if(typeof e!="function")throw new Error("PriorityQueue remove expects a callback");const t=[],s=[];for(;!this.isEmpty();){const n=this.pop();e(n)?t.push(n):s.push(n)}return s.forEach(n=>this.push(n)),t}contains(e){if(typeof e!="function")throw new Error("PriorityQueue contains expects a callback");let t=!1;const s=[];for(;!this.isEmpty();){const n=this.pop();if(s.push(n),e(n)){t=!0;break}}return s.forEach(n=>this.push(n)),t}size(){return this._heap.size()}isEmpty(){return this._heap.isEmpty()}clear(){this._heap.clear()}toArray(){return this._heap.clone().sort().reverse()}[Symbol.iterator](){let e=this.size();return{next:()=>(e-=1,{value:this.pop(),done:e===-1})}}};j.fromArray=function(e,t){return new j(t,e)};q.PriorityQueue=j;/**
 * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>
 * @license MIT
 */const{PriorityQueue:Le}=q;let W=class extends Le{constructor(e,t){if(e&&typeof e=="object"&&typeof e.compare=="function"){const s=(n,l)=>e.compare(n,l)<=0?-1:1;super(s,t)}else{const s=e;if(s&&typeof s!="function")throw new Error("MinPriorityQueue constructor requires a callback for object values");const n=(l,d)=>{const v=typeof s=="function"?s(l):l,x=typeof s=="function"?s(d):d;return v<=x?-1:1};super(n,t)}}enqueue(e){return super.enqueue(e),this}push(e){return this.enqueue(e)}};W.fromArray=function(e,t){return new W(t,e)};se.MinPriorityQueue=W;var ie={};/**
 * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>
 * @license MIT
 */const{PriorityQueue:Te}=q;let K=class extends Te{constructor(e,t){if(e&&typeof e=="object"&&typeof e.compare=="function"){const s=(n,l)=>e.compare(n,l)<=0?-1:1;super(s,t)}else{const s=e;if(s&&typeof s!="function")throw new Error("MaxPriorityQueue constructor requires a callback for object values");const n=(l,d)=>{const v=typeof s=="function"?s(l):l,x=typeof s=="function"?s(d):d;return v<x?1:-1};super(n,t)}}enqueue(e){return super.enqueue(e),this}push(e){return this.enqueue(e)}};K.fromArray=function(e,t){return new K(t,e)};ie.MaxPriorityQueue=K;const{MinPriorityQueue:Ue}=se,{MaxPriorityQueue:Ge}=ie,{PriorityQueue:Be}=q;var Fe={MinPriorityQueue:Ue,MaxPriorityQueue:Ge,PriorityQueue:Be};const E=p=>(Ae("data-v-0c902867"),p=p(),Qe(),p),je=E(()=>u("h1",null,"一笔画游戏",-1)),We=E(()=>u("p",{style:{"margin-bottom":"10px","margin-top":"0px"}},"点击起点开始游戏，访问所有格子即获胜。",-1)),Ke=E(()=>u("p",{style:{"margin-bottom":"10px","margin-top":"0px"}},"每次只能移动到相邻的格子。不能访问已经走过的格子，不能穿过障碍物。",-1)),Je={class:"container"},Xe={class:"top-area"},Ye={class:"grid-container"},Ze={key:0,class:"loading-overlay"},et=E(()=>u("div",{class:"loading-spinner"},null,-1)),tt=E(()=>u("div",{class:"loading-text"},"正在生成地图中...",-1)),st=[et,tt],rt=["onClick"],at={key:0,class:"start-label"},it={class:"controls"},nt={class:"game-info"},ot={class:"control-group"},lt={class:"ratio-value"},ut={class:"control-group"},ct={class:"ratio-value"},ht={class:"control-group"},pt={class:"ratio-value"},ft=He('<div class="legend" data-v-0c902867><div class="legend-item" data-v-0c902867><div class="color-box start" data-v-0c902867></div><span data-v-0c902867>起点</span></div><div class="legend-item" data-v-0c902867><div class="color-box obstacle" data-v-0c902867></div><span data-v-0c902867>障碍物</span></div><div class="legend-item" data-v-0c902867><div class="color-box path" data-v-0c902867></div><span data-v-0c902867>答案路径</span></div><div class="legend-item" data-v-0c902867><div class="color-box visited" data-v-0c902867></div><span data-v-0c902867>已访问</span></div><div class="legend-item" data-v-0c902867><div class="color-box current" data-v-0c902867></div><span data-v-0c902867>当前位置</span></div></div>',1),dt={__name:"Onestroke",setup(p){const e=_(6),t=_(5),s=_(.2),n=_([]),l=_(null),d=_(null),v=_([]),x=_(!1),y=_(""),m=_(""),k=_(!1),P=_([]),O=_(!1),ne=T(()=>({gridTemplateColumns:`repeat(${e.value}, 1fr)`})),oe=T(()=>v.value.length),le=T(()=>n.value.filter(r=>!r.isObstacle).length),R=async()=>{O.value=!0,await new Promise(i=>setTimeout(i,50)),Y();const r=1e4;let a=!1;for(let i=0;i<r&&!a;i++){const o=J(),c=ue(o),h=X(c);h&&h.path.length>0&&(n.value=h.cells,P.value=h.path,l.value=h.start,d.value=h.start,y.value="点击起点开始一笔画",m.value="",k.value=!1,a=!0)}if(!a){const i=J(),o=X(i);o&&(n.value=o.cells,P.value=o.path,l.value=o.start,d.value=o.start,y.value="点击起点开始一笔画 (简化版本)",m.value="",k.value=!1)}O.value=!1},J=()=>{const r=[];for(let a=0;a<t.value;a++)for(let i=0;i<e.value;i++)r.push({x:i,y:a,isObstacle:!1,isStart:!1,isInPath:!1,isVisited:!1,isCurrent:!1});return r},ue=r=>{const a=[...r.map(w=>({...w}))],i=e.value*t.value,o=Math.floor(i*s.value),c=Math.max(4,Math.floor(i*.3)),h=i-c,f=Math.min(o,h);if(f<=0)return a;let g=0;const b=f*10;for(let w=0;w<b&&g<f;w++){const Z=Math.floor(Math.random()*a.length),A=a[Z];A.isObstacle||(A.isObstacle=!0,ce(a)?g++:A.isObstacle=!1)}return a},ce=r=>{const a=r.filter(c=>!c.isObstacle);if(a.length===0)return!1;const i=new Set,o=[a[0]];for(i.add(C(a[0]));o.length>0;){const c=o.shift(),h=D(c,r);for(const f of h){const g=C(f);i.has(g)||(i.add(g),o.push(f))}}return i.size===a.length},X=r=>{const a=r.filter(o=>!o.isObstacle);if(a.length===0)return null;const i=pe([...a]);for(const o of i){const c=he(r,o);if(c&&c.path.length===a.length)return{cells:r.map(h=>({...h,isStart:h.x===o.x&&h.y===o.y})),path:c.path,start:o}}return null},he=(r,a)=>{const i=r.filter(b=>!b.isObstacle),o=i.length,c=new Map;i.forEach(b=>{const w=C(b);c.set(w,D(b,r))});const h=[],f=new Set,g=b=>{const w=C(b);if(f.has(w))return!1;if(f.add(w),h.push(b),h.length===o)return!0;const A=(c.get(w)||[]).filter(M=>!f.has(C(M))),L=new Fe.MinPriorityQueue(M=>{const we=C(M);return(c.get(we)||[]).filter(be=>!f.has(C(be))).length});for(A.forEach(M=>L.enqueue(M));!L.isEmpty();){const M=L.dequeue();if(g(M))return!0}return f.delete(w),h.pop(),!1};return g(a)?{path:[...h]}:null},C=r=>`${r.x}-${r.y}`,D=(r,a)=>{const i=[],o=[{dx:0,dy:-1},{dx:1,dy:0},{dx:0,dy:1},{dx:-1,dy:0}];for(const c of o){const h=r.x+c.dx,f=r.y+c.dy;if(h>=0&&h<e.value&&f>=0&&f<t.value){const g=a[f*e.value+h];g.isObstacle||i.push(g)}}return i},pe=r=>{const a=[...r];for(let i=a.length-1;i>0;i--){const o=Math.floor(Math.random()*(i+1));[a[i],a[o]]=[a[o],a[i]]}return a},fe=r=>({start:r.isStart,obstacle:r.isObstacle,path:r.isInPath&&k.value,visited:r.isVisited,current:r.isCurrent}),de=r=>{if(!(x.value||r.isObstacle||k.value)){if(r.isStart&&v.value.length===0){ve();return}if(v.value.length>0){const a=d.value;D(a,n.value).some(o=>o.x===r.x&&o.y===r.y)&&!r.isVisited?_e(r):(y.value="只能移动到相邻且未访问的格子",m.value="error")}}},ve=()=>{v.value=[l.value],l.value.isVisited=!0,l.value.isCurrent=!0,d.value=l.value,y.value="继续绘制路径",m.value=""},_e=r=>{d.value.isCurrent=!1,r.isCurrent=!0,r.isVisited=!0,v.value.push(r),d.value=r,ye()},ye=()=>{const r=n.value.filter(a=>!a.isObstacle).length;v.value.length===r?(x.value=!0,y.value="恭喜!你成功完成了一笔画!",m.value="success"):(y.value=`已访问 ${v.value.length}/${r} 个格子`,m.value="")},me=()=>{Y(),n.value.forEach(r=>{r.isVisited=!1,r.isCurrent=!1,r.isInPath=!1}),l.value&&(l.value.isCurrent=!0,d.value=l.value),y.value="点击起点开始一笔画",m.value="",k.value=!1},ge=()=>{if(n.value.forEach(r=>{r.isInPath=!1,r.isVisited=!1,r.isCurrent=!1}),v.value=[],d.value=null,x.value=!1,P.value&&P.value.length>0){k.value=!0;let r=0;P.value.forEach((a,i)=>{setTimeout(()=>{const o=n.value.find(c=>c.x===a.x&&c.y===a.y&&!c.isObstacle);o&&(o.isInPath=!0)},r),r+=100}),setTimeout(()=>{y.value=`答案路径已显示完成 (${P.value.length} 步)`,m.value="success"},r),y.value="正在显示答案路径...",m.value=""}else y.value="无法找到一笔画路径",m.value="error"},Y=()=>{v.value=[],d.value=null,x.value=!1};return Ce([e,t,s],()=>{R()}),Me(()=>{R()}),(r,a)=>(Q(),V(te,null,[je,We,Ke,u("div",Je,[u("div",Xe,[u("div",Ye,[O.value?(Q(),V("div",Ze,st)):ee("",!0),u("div",{class:U(["grid",{generating:O.value}]),style:ke(ne.value)},[(Q(!0),V(te,null,Pe(n.value,(i,o)=>(Q(),V("div",{key:o,class:U(["cell",fe(i)]),onClick:c=>de(i)},[i.isStart?(Q(),V("span",at,"起")):ee("",!0)],10,rt))),128))],6)]),u("div",it,[u("div",nt,[u("p",null,"已访问: "+H(oe.value)+"/"+H(le.value)+" 个格子",1)]),u("div",ot,[u("label",null,[G(" 宽度 "),B(u("input",{type:"range","onUpdate:modelValue":a[0]||(a[0]=i=>e.value=i),min:"3",max:"6"},null,512),[[F,e.value,void 0,{number:!0}]]),u("span",lt,H(e.value),1)])]),u("div",ut,[u("label",null,[G(" 高度 "),B(u("input",{type:"range","onUpdate:modelValue":a[1]||(a[1]=i=>t.value=i),min:"3",max:"6"},null,512),[[F,t.value,void 0,{number:!0}]]),u("span",ct,H(t.value),1)])]),u("div",ht,[u("label",null,[G(" 障碍物比例 "),B(u("input",{type:"range","onUpdate:modelValue":a[2]||(a[2]=i=>s.value=i),min:"0",max:"0.3",step:"0.05"},null,512),[[F,s.value,void 0,{number:!0}]]),u("span",pt,H((s.value*100).toFixed(0))+"%",1)])]),u("div",{class:"buttons"},[u("button",{onClick:R},"生成新地图"),u("button",{onClick:me,style:{"background-color":"gray"}},"重新开始"),u("button",{onClick:ge,style:{"background-color":"cornflowerblue"}},"查看答案")]),u("div",{class:U(["result",m.value])},H(y.value),3)])]),ft])],64))}},wt=xe(dt,[["__scopeId","data-v-0c902867"]]);export{wt as default};
